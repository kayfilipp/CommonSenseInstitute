import requests as req
from datetime import datetime
import calendar
import re
import os
REG_KEY = os.environ['BLS_API_KEY']
BLS_API_ROOT = "https://api.bls.gov/publicAPI/v2/timeseries/data"
START_YEAR = os.getenv('START_YEAR', 2000)
END_YEAR = datetime.now().year


def consumer_price_index_midwest_monthly(return_latest: bool = False) -> dict:
    return __get_bls_data('CUUR0200SA0', report_time_series_frequency='monthly', return_latest=return_latest)


def consumer_price_index_midwest_half(return_latest: bool = False) -> dict:
    return __get_bls_data('CUUS0200SA0', report_time_series_frequency='half', return_latest=return_latest)


def __get_bls_data(report_id: str, report_time_series_frequency: str, return_latest: bool = False):

    data = {'registrationkey': REG_KEY, 'seriesid': report_id, 'startyear': START_YEAR, 'endyear': END_YEAR}
    api_call = req.post(url=BLS_API_ROOT, data=data)
    data = api_call.json()

    if data['status'] == 'REQUEST_NOT_PROCESSED':
        raise ValueError('Invalid API Key or limit exceeded.')

    time_series_data = data['Results']['series'][0]['data']

    if not time_series_data:
        raise ValueError('No Data Available.')

    return [

        {
            'value': row['value'],
            'date': __get_row_datetime(row, report_time_series_frequency),
            'type': 'Semi-Annual'
        }

        for row in time_series_data
        if not return_latest or (return_latest and row.get('latest', None))
    ]


def __get_row_datetime(row: dict, report_time_series_frequency: str) -> datetime:
    """
    :param row: a dict generated by the BLS api
    :param report_time_series_frequency = ['monthly', 'half']
    :return: the last day of the month supplied in the period key.
    if the period is M13 (annual) then we return end of year
    """

    year = int(row['year'])
    month_period = row['period']
    month_int = __strip_int_from_str(month_period)

    if report_time_series_frequency == 'monthly':
        if month_int <= 12:
            return __end_of_month(year, month_int)
        return datetime(year=year, month=12, day=31)

    if report_time_series_frequency == 'half':
        return __get_half_datetime(row)

    raise ValueError('Report type invalid.')


def __get_half_datetime(row) -> datetime:

    year = int(row['year'])
    month, day = (6, 30) if row['period'] == 'S01' else (12, 31)
    return datetime(year=year, month=month, day=day)


def __strip_int_from_str(s: str) -> int:
    return int(re.sub(r'[^0-9]', '', s))


def __end_of_month(year: int, month: int) -> int:
    return datetime(
        year=year,
        month=month,
        day=calendar.monthrange(year, month)[1]
    )
